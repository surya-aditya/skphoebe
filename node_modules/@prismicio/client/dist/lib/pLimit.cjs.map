{"version":3,"file":"pLimit.cjs","sources":["../../../src/lib/pLimit.ts"],"sourcesContent":["/*\n ** Core logic from https://github.com/sindresorhus/p-limit\n ** Many thanks to @sindresorhus\n */\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyFunction = (...arguments_: readonly any[]) => unknown\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n/**\n * @param fn - Promise-returning/async function.\n * @param arguments - Any arguments to pass through to `fn`. Support for passing\n *   arguments on to the `fn` is provided in order to be able to avoid creating\n *   unnecessary closures. You probably don't need this optimization unless\n *   you're pushing a lot of functions.\n *\n * @returns The promise returned by calling `fn(...arguments)`.\n */\nexport type LimitFunction = <TArguments extends unknown[], TReturnType>(\n\tfunction_: (\n\t\t...arguments_: TArguments\n\t) => PromiseLike<TReturnType> | TReturnType,\n\t...arguments_: TArguments\n) => Promise<TReturnType>\n\n/**\n * Creates a limiting function that will only execute one promise at a time and\n * respect a given interval between each call.\n *\n * @param args - Options for the function, `interval` is the minimum time to\n *   wait between each promise execution.\n *\n * @returns A limiting function as per configuration, see {@link LimitFunction}.\n */\nexport const pLimit = ({\n\tinterval,\n}: { interval?: number } = {}): LimitFunction => {\n\tconst queue: AnyFunction[] = []\n\tlet busy = false\n\tlet lastCompletion = 0\n\n\tconst resumeNext = () => {\n\t\tif (!busy && queue.length > 0) {\n\t\t\tqueue.shift()?.()\n\t\t\tbusy = true\n\t\t}\n\t}\n\n\tconst next = () => {\n\t\tbusy = false\n\n\t\tresumeNext()\n\t}\n\n\tconst run = async (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\tconst timeSinceLastCompletion = Date.now() - lastCompletion\n\n\t\tif (interval && timeSinceLastCompletion < interval) {\n\t\t\tawait sleep(interval - timeSinceLastCompletion)\n\t\t}\n\t\tconst result = (async () => function_(...arguments_))()\n\n\t\tresolve(result)\n\n\t\ttry {\n\t\t\tawait result\n\t\t} catch {}\n\n\t\tlastCompletion = Date.now()\n\n\t\tnext()\n\t}\n\n\tconst enqueue = (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\t// Queue `internalResolve` instead of the `run` function\n\t\t// to preserve asynchronous context.\n\t\tnew Promise((internalResolve) => {\n\t\t\tqueue.push(internalResolve)\n\t\t}).then(run.bind(undefined, function_, resolve, arguments_))\n\t\t;(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve()\n\n\t\t\tif (!busy) {\n\t\t\t\tresumeNext()\n\t\t\t}\n\t\t})()\n\t}\n\n\treturn ((function_: AnyFunction, ...arguments_: unknown[]) =>\n\t\tnew Promise<unknown>((resolve) => {\n\t\t\tenqueue(function_, resolve, arguments_)\n\t\t})) as LimitFunction\n}\n"],"names":[],"mappings":";;AAQA,MAAM,QAAQ,CAAC,OAAe,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;AA2BvE,MAAM,SAAS,CAAC,EACtB,SAAQ,IACkB,OAAqB;AAC/C,QAAM,QAAuB,CAAA;AAC7B,MAAI,OAAO;AACX,MAAI,iBAAiB;AAErB,QAAM,aAAa,MAAK;;AACvB,QAAI,CAAC,QAAQ,MAAM,SAAS,GAAG;AAC9B,kBAAM,YAAN;AACO,aAAA;AAAA,IACR;AAAA,EAAA;AAGD,QAAM,OAAO,MAAK;AACV,WAAA;;;AAKR,QAAM,MAAM,OACX,WACA,SACA,eACG;AACG,UAAA,0BAA0B,KAAK,IAAA,IAAQ;AAEzC,QAAA,YAAY,0BAA0B,UAAU;AAC7C,YAAA,MAAM,WAAW,uBAAuB;AAAA,IAC/C;AACA,UAAM,UAAU,YAAY,UAAU,GAAG,UAAU;AAEnD,YAAQ,MAAM;AAEV,QAAA;AACG,YAAA;AAAA,IAAA,QACC;AAAA,IAAC;AAET,qBAAiB,KAAK;;;AAKvB,QAAM,UAAU,CACf,WACA,SACA,eACG;AAGC,QAAA,QAAQ,CAAC,oBAAmB;AAC/B,YAAM,KAAK,eAAe;AAAA,IAAA,CAC1B,EAAE,KAAK,IAAI,KAAK,QAAW,WAAW,SAAS,UAAU,CAAC;AAC1D,KAAC,YAAW;AAKZ,YAAM,QAAQ;AAEd,UAAI,CAAC,MAAM;;MAEX;AAAA,IAAA;;AAIF,SAAQ,CAAC,cAA2B,eACnC,IAAI,QAAiB,CAAC,YAAW;AACxB,YAAA,WAAW,SAAS,UAAU;AAAA,EAAA,CACtC;AACH;;"}