import { PrismicMigrationAsset } from "../types/migration/Asset.js";
import { PrismicMigrationDocument } from "../types/migration/Document.js";
import { LinkType } from "../types/value/link.js";
import { RichTextNodeType } from "../types/value/richText.js";
import { link } from "../helpers/isFilled.js";
import { contentRelationship, image, linkToMedia, rtImageNode } from "./isMigrationValue.js";
import { getOptionalLinkProperties } from "./getOptionalLinkProperties.js";
async function resolveMigrationContentRelationship(relation) {
  if (typeof relation === "function") {
    return resolveMigrationContentRelationship(await relation());
  }
  if (relation instanceof PrismicMigrationDocument) {
    return relation.document.id ? { link_type: LinkType.Document, id: relation.document.id } : { link_type: LinkType.Any };
  }
  const optionalLinkProperties = relation && "link_type" in relation ? getOptionalLinkProperties(relation) : void 0;
  if (relation) {
    if (contentRelationship(relation.id) || typeof relation.id !== "string") {
      return {
        ...optionalLinkProperties,
        ...await resolveMigrationContentRelationship(relation.id)
      };
    }
    return {
      ...optionalLinkProperties,
      link_type: LinkType.Document,
      id: relation.id
    };
  }
  return {
    ...optionalLinkProperties,
    link_type: LinkType.Any
  };
}
const resolveMigrationImage = (image2, migration, withThumbnails) => {
  var _a;
  const { id: master, ...thumbnails } = image2 instanceof PrismicMigrationAsset ? { id: image2 } : image2;
  const asset = (_a = migration._assets.get(master.config.id)) == null ? void 0 : _a.asset;
  const maybeInitialField = master.originalField;
  if (asset) {
    const parameters = ((maybeInitialField == null ? void 0 : maybeInitialField.url) || asset.url).split("?")[1];
    const url = `${asset.url.split("?")[0]}${parameters ? `?${parameters}` : ""}`;
    const dimensions = {
      width: asset.width,
      height: asset.height
    };
    const edit = maybeInitialField && "edit" in maybeInitialField ? maybeInitialField == null ? void 0 : maybeInitialField.edit : { x: 0, y: 0, zoom: 1, background: "transparent" };
    const alt = master.config.alt || asset.alt || null;
    const resolvedThumbnails = {};
    if (withThumbnails) {
      for (const [name, thumbnail] of Object.entries(thumbnails)) {
        const resolvedThumbnail = resolveMigrationImage(thumbnail, migration);
        if (resolvedThumbnail) {
          resolvedThumbnails[name] = resolvedThumbnail;
        }
      }
    }
    return {
      id: asset.id,
      url,
      dimensions,
      edit,
      alt,
      copyright: asset.credits || null,
      ...resolvedThumbnails
    };
  }
};
const resolveMigrationRTImageNode = async (rtImageNode2, migration) => {
  const image2 = resolveMigrationImage(rtImageNode2.id, migration);
  if (image2) {
    const linkTo = await resolveMigrationDocumentData(rtImageNode2.linkTo, migration);
    return {
      ...image2,
      type: RichTextNodeType.image,
      linkTo: link(linkTo) ? linkTo : void 0
    };
  }
};
const resolveMigrationLinkToMedia = (linkToMedia2, migration) => {
  var _a;
  const asset = (_a = migration._assets.get(linkToMedia2.id.config.id)) == null ? void 0 : _a.asset;
  const optionalLinkProperties = getOptionalLinkProperties(linkToMedia2);
  if (asset) {
    return {
      ...optionalLinkProperties,
      id: asset.id,
      link_type: LinkType.Media
    };
  }
  return {
    ...optionalLinkProperties,
    link_type: LinkType.Any
  };
};
async function resolveMigrationDocumentData(input, migration) {
  if (contentRelationship(input)) {
    return resolveMigrationContentRelationship(input);
  }
  if (image(input)) {
    return resolveMigrationImage(input, migration, true);
  }
  if (linkToMedia(input)) {
    return resolveMigrationLinkToMedia(input, migration);
  }
  if (rtImageNode(input)) {
    return resolveMigrationRTImageNode(input, migration);
  }
  if (typeof input === "function") {
    return await resolveMigrationDocumentData(await input(), migration);
  }
  if (Array.isArray(input)) {
    const res = [];
    for (const element of input) {
      res.push(await resolveMigrationDocumentData(element, migration));
    }
    return res.filter(Boolean);
  }
  if (input && typeof input === "object") {
    const res = {};
    for (const key in input) {
      res[key] = await resolveMigrationDocumentData(input[key], migration);
    }
    return res;
  }
  return input;
}
export {
  resolveMigrationContentRelationship,
  resolveMigrationDocumentData,
  resolveMigrationImage,
  resolveMigrationLinkToMedia,
  resolveMigrationRTImageNode
};
//# sourceMappingURL=resolveMigrationDocumentData.js.map
