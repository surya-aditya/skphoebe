{"version":3,"file":"Client.cjs","sources":["../../src/Client.ts"],"sourcesContent":["import { appendFilters } from \"./lib/appendFilters\"\nimport { castThunk } from \"./lib/castThunk\"\nimport { devMsg } from \"./lib/devMsg\"\nimport { everyTagFilter } from \"./lib/everyTagFilter\"\nimport { findMasterRef } from \"./lib/findMasterRef\"\nimport { findRefByID } from \"./lib/findRefByID\"\nimport { findRefByLabel } from \"./lib/findRefByLabel\"\nimport { getPreviewCookie } from \"./lib/getPreviewCookie\"\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\"\nimport { someTagsFilter } from \"./lib/someTagsFilter\"\nimport { typeFilter } from \"./lib/typeFilter\"\n\nimport type { Query } from \"./types/api/query\"\nimport type { Ref } from \"./types/api/ref\"\nimport type { Form, Repository } from \"./types/api/repository\"\nimport type { PrismicDocument } from \"./types/value/document\"\n\nimport { ForbiddenError } from \"./errors/ForbiddenError\"\nimport { NotFoundError } from \"./errors/NotFoundError\"\nimport { ParsingError } from \"./errors/ParsingError\"\nimport { PreviewTokenExpiredError } from \"./errors/PreviewTokenExpired\"\nimport { PrismicError } from \"./errors/PrismicError\"\nimport { RefExpiredError } from \"./errors/RefExpiredError\"\nimport { RefNotFoundError } from \"./errors/RefNotFoundError\"\nimport { RepositoryNotFoundError } from \"./errors/RepositoryNotFoundError\"\n\nimport type { LinkResolverFunction } from \"./helpers/asLink\"\nimport { asLink } from \"./helpers/asLink\"\n\nimport {\n\ttype AbortSignalLike,\n\tBaseClient,\n\ttype BaseClientConfig,\n\ttype FetchParams,\n\ttype HttpRequestLike,\n} from \"./BaseClient\"\nimport type { BuildQueryURLArgs } from \"./buildQueryURL\"\nimport { buildQueryURL } from \"./buildQueryURL\"\nimport { filter } from \"./filter\"\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\"\nimport { getRepositoryName } from \"./getRepositoryName\"\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\"\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500\n\n/**\n * The default number of milliseconds to wait before retrying a rate-limited\n * `fetch()` request (429 response code). The default value is only used if the\n * response does not include a `retry-after` header.\n *\n * The API allows up to 200 requests per second.\n */\nconst DEFUALT_RETRY_AFTER_MS = 1000\n\n/**\n * The maximum number of attemps to retry a query with an invalid ref. We allow\n * multiple attempts since each attempt may use a different (and possibly\n * invalid) ref. Capping the number of attemps prevents infinite loops.\n */\nconst MAX_INVALID_REF_RETRY_ATTEMPS = 3\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends PrismicDocument,\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID\n\t\t\treleaseID: string\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel\n\t\t\treleaseLabel: string\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual\n\t\t\tref: RefStringOrThunk\n\t  }\n)\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>)\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The full Rest API V2 endpoint for the repository. This is only helpful if\n\t * you're using Prismic behind a proxy which we do not recommend.\n\t *\n\t * @defaultValue `getRepositoryEndpoint(repositoryNameOrEndpoint)`\n\t */\n\tdocumentAPIEndpoint?: string\n\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url`\n\t * property is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\" | \"brokenRoute\"\n\t>\n} & BaseClientConfig\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number\n}\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs<LinkResolverReturnType> = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: LinkResolverFunction<LinkResolverReturnType>\n\n\t/**\n\t * A fallback URL if the link resolver does not return a value.\n\t */\n\tdefaultURL: string\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string\n}\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Client<\n\tTDocuments extends PrismicDocument = PrismicDocument,\n> extends BaseClient {\n\t#repositoryName: string | undefined\n\n\t/**\n\t * The Prismic repository's name.\n\t */\n\tset repositoryName(value: string) {\n\t\tthis.#repositoryName = value\n\t}\n\n\t/**\n\t * The Prismic repository's name.\n\t */\n\tget repositoryName(): string {\n\t\tif (!this.#repositoryName) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`A repository name is required for this method but one could not be inferred from the provided API endpoint (\\`${this.documentAPIEndpoint}\\`). To fix this error, provide a repository name when creating the client. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn this.#repositoryName\n\t}\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t */\n\tdocumentAPIEndpoint: string\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t *\n\t * @deprecated Use `documentAPIEndpoint` instead.\n\t */\n\t// TODO: Remove in v8.\n\tset endpoint(value: string) {\n\t\tthis.documentAPIEndpoint = value\n\t}\n\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t *\n\t * @deprecated Use `documentAPIEndpoint` instead.\n\t */\n\t// TODO: Remove in v8.\n\tget endpoint(): string {\n\t\treturn this.documentAPIEndpoint\n\t}\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during\n\t * queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t}\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: Repository | undefined\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as in some Node.js versions, the `fetch` option must be provided as\n\t * part of the `options` parameter.\n\t *\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n\t *   API V2 endpoint for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, options: ClientConfig = {}) {\n\t\tsuper(options)\n\n\t\tif (\n\t\t\t(options.documentAPIEndpoint ||\n\t\t\t\tisRepositoryEndpoint(repositoryNameOrEndpoint)) &&\n\t\t\tprocess.env.NODE_ENV === \"development\"\n\t\t) {\n\t\t\tconst documentAPIEndpoint =\n\t\t\t\toptions.documentAPIEndpoint || repositoryNameOrEndpoint\n\n\t\t\t// Matches non-API v2 `.prismic.io` endpoints, see: https://regex101.com/r/xRsavu/1\n\t\t\tif (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(documentAPIEndpoint)) {\n\t\t\t\tthrow new PrismicError(\n\t\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst hostname = new URL(documentAPIEndpoint).hostname.toLowerCase()\n\n\t\t\t// Matches non-.cdn `.prismic.io` endpoints\n\t\t\tif (\n\t\t\t\thostname.endsWith(\".prismic.io\") &&\n\t\t\t\t!hostname.endsWith(\".cdn.prismic.io\")\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] The client was created with a non-CDN endpoint. Convert it to the CDN endpoint for better performance. For more details, see ${devMsg(\"endpoint-must-use-cdn\")}`,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Warn if the user provided both a repository endpoint and an `documentAPIEndpoint` and they are different\n\t\t\tif (\n\t\t\t\toptions.documentAPIEndpoint &&\n\t\t\t\tisRepositoryEndpoint(repositoryNameOrEndpoint) &&\n\t\t\t\trepositoryNameOrEndpoint !== options.documentAPIEndpoint\n\t\t\t) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] Multiple incompatible endpoints were provided. Create the client using a repository name to prevent this error. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\tthis.documentAPIEndpoint = repositoryNameOrEndpoint\n\t\t\ttry {\n\t\t\t\tthis.repositoryName = getRepositoryName(repositoryNameOrEndpoint)\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] A repository name could not be inferred from the provided endpoint (\\`${repositoryNameOrEndpoint}\\`). Some methods will be disabled. Create the client using a repository name to prevent this warning. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.documentAPIEndpoint =\n\t\t\t\toptions.documentAPIEndpoint ||\n\t\t\t\tgetRepositoryEndpoint(repositoryNameOrEndpoint)\n\t\t\tthis.repositoryName = repositoryNameOrEndpoint\n\t\t}\n\n\t\tthis.accessToken = options.accessToken\n\t\tthis.routes = options.routes\n\t\tthis.brokenRoute = options.brokenRoute\n\t\tthis.defaultParams = options.defaultParams\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref)\n\t\t}\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this)\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the\n\t * browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews()\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the\n\t * server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req)\n\t * })\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's\n\t *   cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req\n\t\tthis.refState.autoPreviewsEnabled = true\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews()\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\tconst { data } = await this._get<TDocument>(params)\n\n\t\treturn data\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst actualParams = { ...params }\n\t\tif (!(params && params.page) && !params?.pageSize) {\n\t\t\tactualParams.pageSize = this.defaultParams?.pageSize ?? 1\n\t\t}\n\t\tconst { data, url } = await this._get<TDocument>(actualParams)\n\n\t\tconst firstResult = data.results[0]\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult\n\t\t}\n\n\t\tthrow new NotFoundError(\"No documents were returned\", url, undefined)\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by filters such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no filters are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll()\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t}\n\n\t\tconst documents: TDocument[] = []\n\t\tlet latestResult: Query<TDocument> | undefined\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page })\n\t\t\tdocuments.push(...latestResult.results)\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY))\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit)\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t *\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.id\", id)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and\n\t * custom type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom\n\t * Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and\n\t * custom type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t)\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific\n\t * custom type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable custom type which\n\t * allows multiple instances of itself.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the singleton custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the custom type, if a matching document\n\t *   exists.\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific custom type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the custom type.\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom\n\t * Type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the custom type.\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendFilters(params, typeFilter(documentType)))\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a\n\t * specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(appendFilters(params, someTagsFilter(tag)))\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\")\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tag)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the\n\t *   tags.\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllBySomeTags([\"food\", \"fruit\"])\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.documentAPIEndpoint)\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken)\n\t\t}\n\n\t\treturn await this.fetch<Repository>(url.toString(), params)\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<Ref[]> {\n\t\tconst repository = await this.getRepository(params)\n\n\t\treturn repository.refs\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findRefByID(refs, id)\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findRefByLabel(refs, label)\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn findMasterRef(refs)\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<Ref[]> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef)\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\n\t\treturn findRefByID(releases, id)\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\n\t\treturn findRefByLabel(releases, label)\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params)\n\n\t\t\tconst url = new URL(tagsForm.action)\n\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken)\n\t\t\t}\n\n\t\t\treturn await this.fetch<string[]>(url.toString(), params)\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params)\n\n\t\t\treturn repository.tags\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\tfetchOptions,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref =\n\t\t\tparams.ref || (await this.getResolvedRefString({ signal, fetchOptions }))\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal, fetchOptions }))\n\t\t\t\t.integrationFieldsRef ||\n\t\t\tundefined\n\n\t\treturn buildQueryURL(this.documentAPIEndpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\tbrokenRoute: params.brokenRoute || this.brokenRoute,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t})\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: ResolvePreviewArgs<LinkResolverReturnType> & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID\n\t\tlet previewToken: string | undefined | null = args.previewToken\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search)\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t} else if (this.refState.httpRequest) {\n\t\t\tif (\"query\" in this.refState.httpRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.refState.httpRequest.query?.documentId as string)\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.refState.httpRequest.query?.token as string)\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.refState.httpRequest &&\n\t\t\t\tthis.refState.httpRequest.url\n\t\t\t) {\n\t\t\t\t// Including \"missing-host://\" by default\n\t\t\t\t// handles a case where Next.js Route Handlers\n\t\t\t\t// only provide the pathname and search\n\t\t\t\t// parameters in the `url` property\n\t\t\t\t// (e.g. `/api/preview?foo=bar`).\n\t\t\t\tconst searchParams = new URL(\n\t\t\t\t\tthis.refState.httpRequest.url,\n\t\t\t\t\t\"missing-host://\",\n\t\t\t\t).searchParams\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t\tsignal: args.signal,\n\t\t\t\tfetchOptions: args.fetchOptions,\n\t\t\t})\n\n\t\t\tconst url = asLink(document, { linkResolver: args.linkResolver })\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future\n\t * queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent()\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param releaseID - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param releaseLabel - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\")\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query\n\t *   content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t}\n\t}\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphQLClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphQLFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * })\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are\n\t *   supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t *\n\t * @experimental\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: Omit<RequestInit, \"signal\"> & { signal?: AbortSignalLike },\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository()\n\t\tconst ref = await this.getResolvedRefString()\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t}\n\n\t\tif (cachedRepository.integrationFieldsRef) {\n\t\t\tunsanitizedHeaders[\"Prismic-integration-field-ref\"] =\n\t\t\t\tcachedRepository.integrationFieldsRef\n\t\t}\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {}\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders]\n\t\t\t}\n\t\t}\n\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t)\n\n\t\t// This prevents the request from being cached unnecessarily.\n\t\t// Without adding this `ref` param, re-running a query\n\t\t// could return a locally cached response, even if the\n\t\t// `ref` changed. This happens because the URL is\n\t\t// identical when the `ref` is not included. Caches may ignore\n\t\t// headers.\n\t\t//\n\t\t// The Prismic GraphQL API ignores the `ref` param.\n\t\turl.searchParams.set(\"ref\", ref)\n\n\t\tconst query = url.searchParams.get(\"query\")\n\t\tif (query) {\n\t\t\turl.searchParams.set(\n\t\t\t\t\"query\",\n\t\t\t\t// Compress the GraphQL query (if it exists) by\n\t\t\t\t// removing whitespace. This is done to\n\t\t\t\t// optimize the query size and avoid\n\t\t\t\t// hitting the upper limit of GET requests\n\t\t\t\t// (2048 characters).\n\t\t\t\tminifyGraphQLQuery(query),\n\t\t\t)\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(params?: FetchParams): Promise<Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL\n\t\t\tthis.cachedRepository = await this.getRepository(params)\n\t\t}\n\n\t\treturn this.cachedRepository\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t *\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params)\n\t\tconst form = cachedRepository.forms[name]\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn form\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref\n\t * thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n\t *   fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined\n\n\t\t\tlet cookieJar: string | null | undefined\n\n\t\t\tif (this.refState.httpRequest?.headers) {\n\t\t\t\tif (\n\t\t\t\t\t\"get\" in this.refState.httpRequest.headers &&\n\t\t\t\t\ttypeof this.refState.httpRequest.headers.get === \"function\"\n\t\t\t\t) {\n\t\t\t\t\t// Web API Headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.get(\"cookie\")\n\t\t\t\t} else if (\"cookie\" in this.refState.httpRequest.headers) {\n\t\t\t\t\t// Express-style headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.cookie\n\t\t\t\t}\n\t\t\t} else if (globalThis.document?.cookie) {\n\t\t\t\tcookieJar = globalThis.document.cookie\n\t\t\t}\n\n\t\t\tif (cookieJar) {\n\t\t\t\tpreviewRef = getPreviewCookie(cookieJar)\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params)\n\n\t\tconst refModeType = this.refState.mode\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)()\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref\n\t}\n\n\t/**\n\t * The private implementation of `this.get`. It returns the API response and\n\t * the URL used to make the request. The URL is sometimes used in the public\n\t * method to include in thrown errors.\n\t *\n\t * This method retries requests that throw `RefNotFoundError` or\n\t * `RefExpiredError`. It contains special logic to retry with the latest\n\t * master ref, provided in the API's error message.\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns An object containing the paginated response containing the result\n\t *   of the query and the URL used to make the API request.\n\t */\n\tprivate async _get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t\tattemptCount = 0,\n\t): Promise<{ data: Query<TDocument>; url: string }> {\n\t\tconst url = await this.buildQueryURL(params)\n\n\t\ttry {\n\t\t\tconst data = await this.fetch<Query<TDocument>>(url, params)\n\n\t\t\treturn { data, url }\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\t!(\n\t\t\t\t\terror instanceof RefNotFoundError || error instanceof RefExpiredError\n\t\t\t\t) ||\n\t\t\t\tattemptCount >= MAX_INVALID_REF_RETRY_ATTEMPS - 1\n\t\t\t) {\n\t\t\t\tthrow error\n\t\t\t}\n\n\t\t\t// If no explicit ref is given (i.e. the master ref from\n\t\t\t// /api/v2 is used), clear the cached repository value.\n\t\t\t// Clearing the cached value prevents other methods from\n\t\t\t// using a known-stale ref.\n\t\t\tif (!params?.ref) {\n\t\t\t\tthis.cachedRepository = undefined\n\t\t\t}\n\n\t\t\tconst masterRef = error.message.match(/Master ref is: (?<ref>.*)$/)\n\t\t\t\t?.groups?.ref\n\t\t\tif (!masterRef) {\n\t\t\t\tthrow error\n\t\t\t}\n\n\t\t\tconst badRef = new URL(url).searchParams.get(\"ref\")\n\t\t\tconst issue = error instanceof RefNotFoundError ? \"invalid\" : \"expired\"\n\t\t\tconsole.warn(\n\t\t\t\t`The ref (${badRef}) was ${issue}. Now retrying with the latest master ref (${masterRef}). If you were previewing content, the response will not include draft content.`,\n\t\t\t)\n\n\t\t\treturn await this._get({ ...params, ref: masterRef }, attemptCount + 1)\n\t\t}\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t *\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprotected async fetch<T = unknown>(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\tconst res = await super.fetch(url, params)\n\n\t\tif (res.status !== 404 && res.status !== 429 && res.json == null) {\n\t\t\tthrow new PrismicError(undefined, url, res.json || res.text)\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200:\n\t\t\tcase 201: {\n\t\t\t\treturn res.json\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid filter syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\tres.json.error || res.json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tres.json,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\t// Not Found\n\t\t\t// - Incorrect repository name (this response has an empty body)\n\t\t\t// - Ref does not exist\n\t\t\t// - Preview token is expired\n\t\t\tcase 404: {\n\t\t\t\tif (res.json === undefined) {\n\t\t\t\t\tthrow new RepositoryNotFoundError(\n\t\t\t\t\t\t`Prismic repository not found. Check that \"${this.documentAPIEndpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\t\turl,\n\t\t\t\t\t\turl.startsWith(this.documentAPIEndpoint) ? undefined : res.text,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (res.json.type === \"api_notfound_error\") {\n\t\t\t\t\tthrow new RefNotFoundError(res.json.message, url, res.json)\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tres.json.type === \"api_security_error\" &&\n\t\t\t\t\t/preview token.*expired/i.test(res.json.message)\n\t\t\t\t) {\n\t\t\t\t\tthrow new PreviewTokenExpiredError(res.json.message, url, res.json)\n\t\t\t\t}\n\n\t\t\t\tthrow new NotFoundError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Gone\n\t\t\t// - Ref is expired\n\t\t\tcase 410: {\n\t\t\t\tthrow new RefExpiredError(res.json.message, url, res.json)\n\t\t\t}\n\n\t\t\t// Too Many Requests\n\t\t\t// - Exceeded the maximum number of requests per second\n\t\t\tcase 429: {\n\t\t\t\tconst parsedRetryAfter = Number(res.headers.get(\"retry-after\"))\n\t\t\t\tconst delay = Number.isNaN(parsedRetryAfter)\n\t\t\t\t\t? DEFUALT_RETRY_AFTER_MS\n\t\t\t\t\t: parsedRetryAfter\n\n\t\t\t\treturn await new Promise((resolve, reject) => {\n\t\t\t\t\tsetTimeout(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(await this.fetch(url, params))\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error)\n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, res.json)\n\t}\n}\n"],"names":["RefStateMode","BaseClient","isRepositoryEndpoint","PrismicError","devMsg","getRepositoryName","getRepositoryEndpoint","NotFoundError","appendFilters","filter","typeFilter","someTagsFilter","everyTagFilter","findRefByID","findRefByLabel","findMasterRef","buildQueryURL","asLink","minifyGraphQLQuery","getPreviewCookie","castThunk","RefNotFoundError","RefExpiredError","ParsingError","ForbiddenError","RepositoryNotFoundError","PreviewTokenExpiredError"],"mappings":"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"}