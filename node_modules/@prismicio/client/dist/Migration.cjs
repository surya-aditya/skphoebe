"use strict";
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _Migration_instances, migratePrismicDocumentData_fn;
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const isValue = require("./lib/isValue.cjs");
const getOptionalLinkProperties = require("./lib/getOptionalLinkProperties.cjs");
const validateAssetMetadata = require("./lib/validateAssetMetadata.cjs");
const Asset = require("./types/migration/Asset.cjs");
const Document = require("./types/migration/Document.cjs");
const link = require("./types/value/link.cjs");
const richText = require("./types/value/richText.cjs");
class Migration {
  constructor() {
    __privateAdd(this, _Migration_instances);
    /**
     * Assets registered in the migration.
     *
     * @internal
     */
    __publicField(this, "_assets", /* @__PURE__ */ new Map());
    /**
     * Documents registered in the migration.
     *
     * @internal
     */
    __publicField(this, "_documents", []);
  }
  /**
   * Registers an asset to be created in the migration from a file, an asset
   * object, or an image or link to media field.
   *
   * @remarks
   * This method does not create the asset in Prismic media library right away.
   * Instead, it registers it in your migration. The asset will be created when
   * the migration is executed through the `writeClient.migrate()` method.
   *
   * @returns A migration asset field instance.
   */
  createAsset(fileOrAssetOrField, filename, { notes, credits, alt, tags } = {}) {
    var _a;
    let config;
    let maybeInitialField;
    if (typeof fileOrAssetOrField === "object" && "url" in fileOrAssetOrField) {
      if ("dimensions" in fileOrAssetOrField || "link_type" in fileOrAssetOrField) {
        const url = fileOrAssetOrField.url.split("?")[0];
        const filename2 = "name" in fileOrAssetOrField ? fileOrAssetOrField.name : url.split("/").pop().split("_").pop();
        const credits2 = "copyright" in fileOrAssetOrField && fileOrAssetOrField.copyright ? fileOrAssetOrField.copyright : void 0;
        const alt2 = "alt" in fileOrAssetOrField && fileOrAssetOrField.alt ? fileOrAssetOrField.alt : void 0;
        if ("dimensions" in fileOrAssetOrField) {
          maybeInitialField = fileOrAssetOrField;
        }
        config = {
          id: fileOrAssetOrField.id,
          file: url,
          filename: filename2,
          notes: void 0,
          credits: credits2,
          alt: alt2,
          tags: void 0
        };
      } else {
        config = {
          id: fileOrAssetOrField.id,
          file: fileOrAssetOrField.url,
          filename: fileOrAssetOrField.filename,
          notes: fileOrAssetOrField.notes,
          credits: fileOrAssetOrField.credits,
          alt: fileOrAssetOrField.alt,
          tags: (_a = fileOrAssetOrField.tags) == null ? void 0 : _a.map(({ name }) => name)
        };
      }
    } else {
      config = {
        id: fileOrAssetOrField,
        file: fileOrAssetOrField,
        filename,
        notes,
        credits,
        alt,
        tags
      };
    }
    validateAssetMetadata.validateAssetMetadata(config);
    const migrationAsset = new Asset.PrismicMigrationAsset(config, maybeInitialField);
    const maybeAsset = this._assets.get(config.id);
    if (maybeAsset) {
      maybeAsset.config.notes = maybeAsset.config.notes || config.notes;
      maybeAsset.config.credits = maybeAsset.config.credits || config.credits;
      maybeAsset.config.alt = maybeAsset.config.alt || config.alt;
      maybeAsset.config.tags = Array.from(/* @__PURE__ */ new Set([...maybeAsset.config.tags || [], ...config.tags || []]));
    } else {
      this._assets.set(config.id, migrationAsset);
    }
    return migrationAsset;
  }
  /**
   * Registers a document to be created in the migration.
   *
   * @remarks
   * This method does not create the document in Prismic right away. Instead, it
   * registers it in your migration. The document will be created when the
   * migration is executed through the `writeClient.migrate()` method.
   *
   * @typeParam TType - Type of the Prismic document to create.
   *
   * @param document - The document to create.
   * @param title - The title of the document to create which will be displayed
   *   in the editor.
   * @param params - Document master language document ID.
   *
   * @returns A migration document instance.
   */
  createDocument(document, title, params) {
    const doc = new Document.PrismicMigrationDocument(document, title, params);
    this._documents.push(doc);
    return doc;
  }
  /**
   * Registers an existing document to be updated in the migration.
   *
   * @remarks
   * This method does not update the document in Prismic right away. Instead, it
   * registers it in your migration. The document will be updated when the
   * migration is executed through the `writeClient.migrate()` method.
   *
   * @typeParam TType - Type of Prismic documents to update.
   *
   * @param document - The document to update.
   * @param title - The title of the document to update which will be displayed
   *   in the editor.
   *
   * @returns A migration document instance.
   */
  updateDocument(document, title) {
    const doc = new Document.PrismicMigrationDocument(document, title);
    this._documents.push(doc);
    return doc;
  }
  /**
   * Registers a document from another Prismic repository to be created in the
   * migration.
   *
   * @remarks
   * This method does not create the document in Prismic right away. Instead, it
   * registers it in your migration. The document will be created when the
   * migration is executed through the `writeClient.migrate()` method.
   *
   * @param document - The document from Prismic to create.
   * @param title - The title of the document to create which will be displayed
   *   in the editor.
   *
   * @returns A migration document instance.
   */
  createDocumentFromPrismic(document, title) {
    const doc = new Document.PrismicMigrationDocument(__privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, {
      type: document.type,
      lang: document.lang,
      uid: document.uid,
      tags: document.tags,
      data: document.data
    }), title, { originalPrismicDocument: document });
    this._documents.push(doc);
    return doc;
  }
  /**
   * Queries a document from the migration instance with a specific UID and
   * custom type.
   *
   * @example
   *
   * ```ts
   * const contentRelationship = migration.createContentRelationship(() =>
   * 	migration.getByUID("blog_post", "my-first-post"),
   * )
   * ```
   *
   * @typeParam TType - Type of the Prismic document returned.
   *
   * @param type - The API ID of the document's custom type.
   * @param uid - The UID of the document.
   *
   * @returns The migration document instance with a UID matching the `uid`
   *   parameter, if a matching document is found.
   */
  getByUID(type, uid) {
    return this._documents.find((doc) => doc.document.type === type && doc.document.uid === uid);
  }
  /**
   * Queries a singleton document from the migration instance for a specific
   * custom type.
   *
   * @example
   *
   * ```ts
   * const contentRelationship = migration.createContentRelationship(() =>
   * 	migration.getSingle("settings"),
   * )
   * ```
   *
   * @typeParam TType - Type of the Prismic document returned.
   *
   * @param type - The API ID of the singleton custom type.
   *
   * @returns The migration document instance for the custom type, if a matching
   *   document is found.
   */
  getSingle(type) {
    return this._documents.find((doc) => doc.document.type === type);
  }
  /**
   * Queries a document from the migration instance for a specific original ID.
   *
   * @example
   *
   * ```ts
   * const contentRelationship = migration.createContentRelationship(() =>
   * 	migration._getByOriginalID("YhdrDxIAACgAcp_b"),
   * )
   * ```
   *
   * @typeParam TType - Type of the Prismic document returned.
   *
   * @param id - The original ID of the Prismic document.
   *
   * @returns The migration document instance for the original ID, if a matching
   *   document is found.
   *
   * @internal
   */
  _getByOriginalID(id) {
    return this._documents.find((doc) => {
      var _a;
      return ((_a = doc.originalPrismicDocument) == null ? void 0 : _a.id) === id;
    });
  }
}
_Migration_instances = new WeakSet();
/**
 * Migrates a Prismic document data from another repository so that it can be
 * created through the current repository's Migration API.
 *
 * @param input - The Prismic document data to migrate.
 *
 * @returns The migrated Prismic document data.
 */
migratePrismicDocumentData_fn = function(input) {
  if (isValue.filledContentRelationship(input)) {
    const optionalLinkProperties = getOptionalLinkProperties.getOptionalLinkProperties(input);
    if (input.isBroken) {
      return {
        ...optionalLinkProperties,
        link_type: link.LinkType.Document,
        // ID needs to be 16 characters long to be considered valid by the API
        id: "_____broken_____",
        isBroken: true
      };
    }
    return {
      ...optionalLinkProperties,
      link_type: link.LinkType.Document,
      id: () => this._getByOriginalID(input.id)
    };
  }
  if (isValue.filledLinkToMedia(input)) {
    const optionalLinkProperties = getOptionalLinkProperties.getOptionalLinkProperties(input);
    return {
      ...optionalLinkProperties,
      link_type: link.LinkType.Media,
      id: this.createAsset(input)
    };
  }
  if (isValue.rtImageNode(input)) {
    const rtImageNode = {
      type: richText.RichTextNodeType.image,
      id: this.createAsset(input)
    };
    if (input.linkTo) {
      rtImageNode.linkTo = __privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, input.linkTo);
    }
    return rtImageNode;
  }
  if (isValue.filledImage(input)) {
    const image = {
      id: this.createAsset(input)
    };
    const { id: _id, url: _url, dimensions: _dimensions, edit: _edit, alt: _alt, copyright: _copyright, ...thumbnails } = input;
    for (const name in thumbnails) {
      if (isValue.filledImage(thumbnails[name])) {
        image[name] = this.createAsset(thumbnails[name]);
      }
    }
    return image;
  }
  if (Array.isArray(input)) {
    return input.map((element) => __privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, element));
  }
  if (input && typeof input === "object") {
    const res = {};
    for (const key in input) {
      res[key] = __privateMethod(this, _Migration_instances, migratePrismicDocumentData_fn).call(this, input[key]);
    }
    return res;
  }
  return input;
};
exports.Migration = Migration;
//# sourceMappingURL=Migration.cjs.map
